// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/hakuna86/golang-token-auth-server-sample/ent/auth"
	"github.com/hakuna86/golang-token-auth-server-sample/ent/predicate"
	"github.com/hakuna86/golang-token-auth-server-sample/ent/user"
)

// AuthUpdate is the builder for updating Auth entities.
type AuthUpdate struct {
	config

	updated_at    *time.Time
	access_token  *string
	refresh_token *string
	user          map[int]struct{}
	clearedUser   bool
	predicates    []predicate.Auth
}

// Where adds a new predicate for the builder.
func (au *AuthUpdate) Where(ps ...predicate.Auth) *AuthUpdate {
	au.predicates = append(au.predicates, ps...)
	return au
}

// SetUpdatedAt sets the updated_at field.
func (au *AuthUpdate) SetUpdatedAt(t time.Time) *AuthUpdate {
	au.updated_at = &t
	return au
}

// SetAccessToken sets the access_token field.
func (au *AuthUpdate) SetAccessToken(s string) *AuthUpdate {
	au.access_token = &s
	return au
}

// SetRefreshToken sets the refresh_token field.
func (au *AuthUpdate) SetRefreshToken(s string) *AuthUpdate {
	au.refresh_token = &s
	return au
}

// SetUserID sets the user edge to User by id.
func (au *AuthUpdate) SetUserID(id int) *AuthUpdate {
	if au.user == nil {
		au.user = make(map[int]struct{})
	}
	au.user[id] = struct{}{}
	return au
}

// SetUser sets the user edge to User.
func (au *AuthUpdate) SetUser(u *User) *AuthUpdate {
	return au.SetUserID(u.ID)
}

// ClearUser clears the user edge to User.
func (au *AuthUpdate) ClearUser() *AuthUpdate {
	au.clearedUser = true
	return au
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (au *AuthUpdate) Save(ctx context.Context) (int, error) {
	if au.updated_at == nil {
		v := auth.UpdateDefaultUpdatedAt()
		au.updated_at = &v
	}
	if len(au.user) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"user\"")
	}
	if au.clearedUser && au.user == nil {
		return 0, errors.New("ent: clearing a unique edge \"user\"")
	}
	return au.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (au *AuthUpdate) SaveX(ctx context.Context) int {
	affected, err := au.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (au *AuthUpdate) Exec(ctx context.Context) error {
	_, err := au.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (au *AuthUpdate) ExecX(ctx context.Context) {
	if err := au.Exec(ctx); err != nil {
		panic(err)
	}
}

func (au *AuthUpdate) sqlSave(ctx context.Context) (n int, err error) {
	var (
		builder  = sql.Dialect(au.driver.Dialect())
		selector = builder.Select(auth.FieldID).From(builder.Table(auth.Table))
	)
	for _, p := range au.predicates {
		p(selector)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err = au.driver.Query(ctx, query, args, rows); err != nil {
		return 0, err
	}
	defer rows.Close()

	var ids []int
	for rows.Next() {
		var id int
		if err := rows.Scan(&id); err != nil {
			return 0, fmt.Errorf("ent: failed reading id: %v", err)
		}
		ids = append(ids, id)
	}
	if len(ids) == 0 {
		return 0, nil
	}

	tx, err := au.driver.Tx(ctx)
	if err != nil {
		return 0, err
	}
	var (
		res     sql.Result
		updater = builder.Update(auth.Table)
	)
	updater = updater.Where(sql.InInts(auth.FieldID, ids...))
	if value := au.updated_at; value != nil {
		updater.Set(auth.FieldUpdatedAt, *value)
	}
	if value := au.access_token; value != nil {
		updater.Set(auth.FieldAccessToken, *value)
	}
	if value := au.refresh_token; value != nil {
		updater.Set(auth.FieldRefreshToken, *value)
	}
	if !updater.Empty() {
		query, args := updater.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if au.clearedUser {
		query, args := builder.Update(auth.UserTable).
			SetNull(auth.UserColumn).
			Where(sql.InInts(user.FieldID, ids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if len(au.user) > 0 {
		for _, id := range ids {
			eid := keys(au.user)[0]
			query, args := builder.Update(auth.UserTable).
				Set(auth.UserColumn, eid).
				Where(sql.EQ(auth.FieldID, id).And().IsNull(auth.UserColumn)).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return 0, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return 0, rollback(tx, err)
			}
			if int(affected) < len(au.user) {
				return 0, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"user\" %v already connected to a different \"Auth\"", keys(au.user))})
			}
		}
	}
	if err = tx.Commit(); err != nil {
		return 0, err
	}
	return len(ids), nil
}

// AuthUpdateOne is the builder for updating a single Auth entity.
type AuthUpdateOne struct {
	config
	id int

	updated_at    *time.Time
	access_token  *string
	refresh_token *string
	user          map[int]struct{}
	clearedUser   bool
}

// SetUpdatedAt sets the updated_at field.
func (auo *AuthUpdateOne) SetUpdatedAt(t time.Time) *AuthUpdateOne {
	auo.updated_at = &t
	return auo
}

// SetAccessToken sets the access_token field.
func (auo *AuthUpdateOne) SetAccessToken(s string) *AuthUpdateOne {
	auo.access_token = &s
	return auo
}

// SetRefreshToken sets the refresh_token field.
func (auo *AuthUpdateOne) SetRefreshToken(s string) *AuthUpdateOne {
	auo.refresh_token = &s
	return auo
}

// SetUserID sets the user edge to User by id.
func (auo *AuthUpdateOne) SetUserID(id int) *AuthUpdateOne {
	if auo.user == nil {
		auo.user = make(map[int]struct{})
	}
	auo.user[id] = struct{}{}
	return auo
}

// SetUser sets the user edge to User.
func (auo *AuthUpdateOne) SetUser(u *User) *AuthUpdateOne {
	return auo.SetUserID(u.ID)
}

// ClearUser clears the user edge to User.
func (auo *AuthUpdateOne) ClearUser() *AuthUpdateOne {
	auo.clearedUser = true
	return auo
}

// Save executes the query and returns the updated entity.
func (auo *AuthUpdateOne) Save(ctx context.Context) (*Auth, error) {
	if auo.updated_at == nil {
		v := auth.UpdateDefaultUpdatedAt()
		auo.updated_at = &v
	}
	if len(auo.user) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"user\"")
	}
	if auo.clearedUser && auo.user == nil {
		return nil, errors.New("ent: clearing a unique edge \"user\"")
	}
	return auo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (auo *AuthUpdateOne) SaveX(ctx context.Context) *Auth {
	a, err := auo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return a
}

// Exec executes the query on the entity.
func (auo *AuthUpdateOne) Exec(ctx context.Context) error {
	_, err := auo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (auo *AuthUpdateOne) ExecX(ctx context.Context) {
	if err := auo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (auo *AuthUpdateOne) sqlSave(ctx context.Context) (a *Auth, err error) {
	var (
		builder  = sql.Dialect(auo.driver.Dialect())
		selector = builder.Select(auth.Columns...).From(builder.Table(auth.Table))
	)
	auth.ID(auo.id)(selector)
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err = auo.driver.Query(ctx, query, args, rows); err != nil {
		return nil, err
	}
	defer rows.Close()

	var ids []int
	for rows.Next() {
		var id int
		a = &Auth{config: auo.config}
		if err := a.FromRows(rows); err != nil {
			return nil, fmt.Errorf("ent: failed scanning row into Auth: %v", err)
		}
		id = a.ID
		ids = append(ids, id)
	}
	switch n := len(ids); {
	case n == 0:
		return nil, &ErrNotFound{fmt.Sprintf("Auth with id: %v", auo.id)}
	case n > 1:
		return nil, fmt.Errorf("ent: more than one Auth with the same id: %v", auo.id)
	}

	tx, err := auo.driver.Tx(ctx)
	if err != nil {
		return nil, err
	}
	var (
		res     sql.Result
		updater = builder.Update(auth.Table)
	)
	updater = updater.Where(sql.InInts(auth.FieldID, ids...))
	if value := auo.updated_at; value != nil {
		updater.Set(auth.FieldUpdatedAt, *value)
		a.UpdatedAt = *value
	}
	if value := auo.access_token; value != nil {
		updater.Set(auth.FieldAccessToken, *value)
		a.AccessToken = *value
	}
	if value := auo.refresh_token; value != nil {
		updater.Set(auth.FieldRefreshToken, *value)
		a.RefreshToken = *value
	}
	if !updater.Empty() {
		query, args := updater.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if auo.clearedUser {
		query, args := builder.Update(auth.UserTable).
			SetNull(auth.UserColumn).
			Where(sql.InInts(user.FieldID, ids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if len(auo.user) > 0 {
		for _, id := range ids {
			eid := keys(auo.user)[0]
			query, args := builder.Update(auth.UserTable).
				Set(auth.UserColumn, eid).
				Where(sql.EQ(auth.FieldID, id).And().IsNull(auth.UserColumn)).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return nil, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return nil, rollback(tx, err)
			}
			if int(affected) < len(auo.user) {
				return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"user\" %v already connected to a different \"Auth\"", keys(auo.user))})
			}
		}
	}
	if err = tx.Commit(); err != nil {
		return nil, err
	}
	return a, nil
}
